> 过早优化是万恶之源, 优化之前请先尽可能的分析业务/使用场景

## Schema 与数据类型优化

* 应根据要执行的查询语句来设计 Schema
* 选用简单的小的的数据类型
* NULL 表示虚位以待
* 确定合适的大类型: 数字, 字符串, 时间, 二进制
    * 数字: tinyint, int, bigint, decimal(变长)
    * 字符串: char, varchar(变长), text(变长)
    * 时间: datetime, timestamp, date, time
    * ENUM 使用 tinyint 可以表示 256 种互斥的状态
    * SET  使用 int 可以表示 32 种并列的权限
    * IP 使用 int 类型保存

## 创建高性能索引

* 索引优化是对查询性能优化最有效的手段
* 理解 B+Tree
* 如果 B+Tree 可以按照某种方式找到值, 那么也可以按照这种方式排序
* 索引选择性 count(dictinct index)/count(*) 
    * 索引一定要有好的选择性
    * 不能出现命中某个索引值时, 出现大量匹配行的情况, 否则毫无用处
* 二级索引的叶节点指向 primary_key
* 按索引顺序扫描是很快的, 而且可以生成有序结果
* 索引覆盖是优化中的优化
* 延迟关联: 通过覆盖索引返回需要的主键, 再根据主键取出需要的数据行

## 查询性能优化

* 查询优化, 索引优化, 表结构优化需要齐头并进
* 了解查询的生命周期, 清楚查询的时间消耗, 分解查询子任务对优化查询有很大意义
* 查询性能低下的根本原因是访问太多数据
    * 查询是否检索了大量的行, 有时候也可能是访问了太多的列
    * MySQL 服务层是否分析大量超过需要的数据行
* 衡量查询开销
    * 响应时间
    * 扫描行数
    * 返回行数
* 扫描行数 ALL > index > range > ref > const
* Using where: 表示 MySQL 服务层需要在存储引擎返回的大量数据行中筛选数据
* 查询优化阶段很错综复杂
* 查询执行阶段很简单: MySQL 只需要重复执行计划中的各个操作, 直到完成所有数据查询
* MySQL EXISTS()
* Using index for group-by: 表示使用了松散索引扫描
* COUNT(*) 表示统计行数
* 快速, 精确, 实现简单: 三者你只能满足其二
* 如果场景合适, 用近似计算代替复杂计算(用稍小的正方形代替圆)
* 可以适当的把计算留给应用程序, 相当于用客户端的算力分担了部分服务端的算力
* 从效率最高的地方开始想是否能应用于查询